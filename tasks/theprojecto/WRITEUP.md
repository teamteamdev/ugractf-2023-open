# The Project O: Write-up

Нам дан сайт, на котором можно — по всей видимости — изучать работу датчиков уцуцуги.

Однако, после регистрации на сайте нам практически ничего не доступно: для просмотра графика нужна некая роль «Зритель», а для получения ключа — административные права.

Посмотрим, что происходит внутри: при авторизации мы получаем Cookie с названием `token` и неким содержимым внутри.

Содержимое состоит из трёх base64-фрагментов, разделённых точкой, а содержимое первых двух из них представлено в формате JSON. Это — [JSON Web Token (JWT)](https://datatracker.ietf.org/doc/html/rfc7519).

Давайте изучим его содержимое. Это можно сделать и вручную, раздекодировав base64, а можно и с помощью специальных инструментов, например, сайта [jwt.io](https://jwt.io/).

![](writeup/token.png)

В теле токена доступно единственное поле — `login`. Однако, гораздо больше интересного мы видим в заголовке: среди стандартных меток мы видим метку `kid` — идентификатор ключа. В соседнем [RFC 7515](https://www.rfc-editor.org/rfc/rfc7515) про JSON Web Signatures мы можем найти, что эта метка используется при наличии нескольких ключей.

Обычно в веб-приложениях хранится список ключей, и каждый ключ имеет какой-то идентификатор. В этом же случае, судя по всему, разработчики решили не заморачиваться, и просто используют имена ключей на файловой системе. Что ж, попробуем воспользоваться этим и указать какой-нибудь другой файл.

Попробуем с чего-то стандартного — например, `/etc/passwd`. Однако, наша кука просто удаляется сервером, и нас возвращает на главную страницу. Это же происходит и, если мы не меняя полезную нагрузку токена, испортим его подпись, заменив пару байт на случайные. Значит, скорее всего, такое поведение говорит нам о том, что подпись неверна.

Давайте попробуем указать какой-нибудь гарантированно несуществующий на системе файл — чтобы понять, что произойдёт. Например, `/ergrahiraireoiewoinge`. Такое действие выдаёт ошибку и просит нас получить токен заново. Таким образом, мы можем различать два случая: когда не удалось получить ключ по `kid` и когда ключ найден, но подпись неверна.

Мы можем перебрать ещё какие-нибудь файлы и заметить, что на довольно коротких файлах, которые наверняка на системе тоже есть, возникает та же ошибка. Например, `/proc/self/oom_score` выдаёт ошибку, а `/proc/self/status` удаляет сессию. Это говорит нам о том, что сервер вероятно ожидает прочитать ключ некоторой длины — и при нехватке данных в файле отказывается проверять токен.

Следовательно, нам нужно найти какой-то файл, который гарантированно существует на удалённой системе, и его содержимое мы можем предсказать.

Самое простое решение — воспользоваться устройством `/dev/zero`. Мы знаем, что что бы сервер оттуда ни вычитал, всё содержимое будет байтами `\x00`. Рекомендуемая длина ключа для HS256 — 32 байта (256 бит). Попробуем сфорджить токен, подписанный 32 нулевыми байтами. Для этого воспользуемся библиотекой `pyjwt`:

```python
>>> import jwt
>>> jwt.encode(
...    {"login": "test"},
...    b"\x00" * 32,
...    algorithm="HS256",
...    headers={"kid": "/dev/zero"}
... )
'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6Ii9kZXYvemVybyJ9.eyJsb2dpbiI6InRlc3QifQ.5LzZh4r2ujG578r3hMoKmF7YNTRA3CqiSBd6urD4DRM'
```

Попробуем установить себе такую куку — и мы успешно входим в пользователя `test`. Теперь мы можем входить под любым пользователем. Для просмотра ключей нам необходимы административные права — и в регистрации сотрудникам УНИИИУ предлагалось *получить* пароль — так что просто наугад попробуем пользователя `admin`.

Нажав на кнопку, видим флаг.

Из более сложных решений для подписи можно было воспользоваться первыми 32 байтами файла `/etc/services` — благо, он также на всех системах одинаков.

Флаг: **ugra_trust_is_the_cornerstone_of_web_mzjanzwpqvnvp8gt**
