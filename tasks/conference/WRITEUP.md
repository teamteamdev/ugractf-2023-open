# Конференция: Write-up

Скачав архив, видим проект Docker Compose — запускаем его, и видим следующую картину:

```
conference-claes-1    | 2023-06-06T13:37:27.308367+00:00 notice: Claes joined the conference! Messages output is restricted.
conference-tony-1     | 2023-06-06T13:37:27.311472+00:00 notice: Tony joined the conference! Messages output is restricted.
conference-jose-1     | 2023-06-06T13:37:27.308573+00:00 notice: Jose joined the conference! Messages output is restricted.
conference-bjorn-1    | 2023-06-06T13:37:27.308339+00:00 notice: Björn joined the conference! Messages output is restricted.
conference-rickard-1  | 2023-06-06T13:37:27.308639+00:00 notice: Rickard joined the conference! Messages output is restricted.
conference-mike-1     | 2023-06-06T13:37:27.308568+00:00 notice: Mike joined the conference! Messages output is restricted.
conference-joe-1      | 2023-06-06T13:37:27.308574+00:00 notice: Joe joined the conference! Messages output is restricted.
conference-robert-1   | 2023-06-06T13:37:27.314507+00:00 notice: Robert joined the conference! Messages output is restricted.
conference-theresa-1  | 2023-06-06T13:37:27.308893+00:00 notice: Theresa joined the conference! Messages output is restricted.
conference-bogumil-1  | 2023-06-06T13:37:27.308330+00:00 notice: Bogumil joined the conference! Messages output is restricted.
conference-patrik-1   | 2023-06-06T13:37:27.309238+00:00 notice: Patrik joined the conference! Messages output is restricted.
```

Больше никакого вывода в консоль мы не получаем, однако в логе сообщается, что вывод неких сообщений ограничен.

Начнём исследование с любого из контейнеров. Внутри мы видим Dockerfile, содержимое которого намекает, что запущенное приложение написано на [Erlang](https://www.youtube.com/watch?v=xrIjfIjssLE). Все контейнеры и приложения одинаковы по структуре, различаются только имена участников конференции. Для каждого контейнера есть свой набор файлов с расширением `.beam` в директории `ebin` — это код виртуальной машины BEAM, на которой исполняются программы на Erlang. Кроме того, присутствует один файл с расширением `.app` — его формат можно найти в документации, и он описывает, с какого модуля начинается запуск приложения.

Изучим сетевое взаимодействие между контейнерами. Для этого через команду `docker network inspect` узнаём, каким сетевым интерфейсом пользуется проект:

```
$ docker network inspect conference_default
[
    {
        "Name": "conference_default",
        "Id": "4a27aeb95efeb74d97233a7aebdc667bbd10eedd95e2acb3ef476adf6fea9723",
        "Created": "2023-06-06T20:36:27.772515052+07:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.19.0.0/16",
                    "Gateway": "172.19.0.1"
                }
            ]
        },
        "Containers": {
            "2850ddf423da9a7222d25ca3753bc1c162afad9ca240f6d9787425df4d371310": {
                "Name": "conference-mike-1",
                "EndpointID": "7ca5f8cbc7a023105e4949ad173b4e862d2c6b46f4818e3e6dd8dfafa7d36c6f",
                "MacAddress": "02:42:ac:13:00:04",
                "IPv4Address": "172.19.0.4/16",
                "IPv6Address": ""
            },
    ...
```

Теперь выясним, какое название у сетевого интерфейса моста, которым связаны контейнеры. Простой способ это сделать — узнать маршрут до любой из машин контейнера:

```
$ ip route get 172.19.0.4
172.19.0.4 dev br-4a27aeb95efe src 172.19.0.1 uid 1000 
    cache 
```

Теперь запускаем Wireshark и начинаем слушать этот интерфейс. Видим стабильный TCP-трафик по множеству соединений на случайных портах. Содержимое на первый взгляд не намекает на какой-либо протокол.

Изучаем общую информацию о языке Erlang. В числе прочего находим, что это язык для _распределённого программирования_ — поддержка работы на кластере машин в сети встроена в виртуальную машину и стандартную библиотеку языка. Протокол обмена данными Erlang называется _Distribution Protocol_. Находим его поддержку в Wireshark (там он называется "ErlDP"). Поскольку соединений между машинами множество, проще объявить _все_ TCP-соединения подключениями по ErlDP.

![](writeup/all_ports.png)

Теперь мы видим содержимое передаваемых сообщений. Если изучить их в работающей некоторое время системе, можно заметить, что структура всех сообщений одинакова.

![](writeup/erl_dp.png)

В документации по Erlang можно найти информацию о tuple, atom, binary и других примитивных типах языка. Изучая сообщения дальше, замечаем, что первая бинарная строка — всегда длиной 16 байт. Сами данные похожи на случайные или зашифрованные.

Из документации или других источников информации можно найти, что внутри файлов BEAM, как и ELF, есть свой собственный формат отладочной информации, который позволяет даже декомпилировать код. Попробуем:

```
$ erl
Erlang/OTP 25 [erts-13.2.2] [source] [64-bit] [smp:16:16] [ds:16:16:10] [async-threads:1] [jit:ns]

Eshell V13.2.2  (abort with ^G)
1> beam_lib:chunks("joe/ebin/actor_joe_srv.beam", [abstract_code]).
{ok,{actor_joe_srv,[{abstract_code,no_abstract_code}]}}
```

К сожалению, удача нам не улыбнулась — вся отладочная информация была обрезана. Однако, для BEAM существует свой дизассемблер, который тоже встроен в язык. Применим его (здесь и далее мы будем разбирать одно из приложений под названием `joe`):
```
2> Content = beam_disasm:file("joe/ebin/actor_joe_srv.beam").
...
3> Str = io_lib:format("~p", [Content]).
...
4> file:write_file("out.erl", Str).
ok
```

Изучим код модулей одного из приложений. `actor_joe.beam` и `actor_joe_sup.beam` короткие и не содержат ничего интересного; основная логика находится в `actor_joe_srv.beam`. Виртуальная машина BEAM относительно малоизвестна; однако поискав по коду, можно найти упоминания `aes_256_ctr`, функций `crypto:crypto_one_time/5` и `crypto:exor/2`. Также можно заметить куски неких сообщений; например:

```
{literal,<<"I see you've managed to fix the bug then.">>},
```

В AES-256 также используется IV длины 16, что совпадает с размером одного из сообщений в сети. Осталось отыскать ключ, тут есть несколько вариантов.

### Находим ключ в работающей программе

Изучая механизмы отладки в Erlang, можно обнаружить, что виртуальная машина поддерживает подключение к работающим нодам — таким образом можно выполнять произвольный код и изучать состояние программы или всего кластера. В Dockerfile находим параметры запуска виртуальной машины: `-sname actor -setcookie cookie`. Подключимся к ноде:

```
$ docker exec -it conference-joe-1 erl -remsh actor -setcookie cookie
Erlang/OTP 26 [erts-14.0] [source] [64-bit] [smp:16:16] [ds:16:16:10] [async-threads:1] [jit]

Eshell V14.0 (press Ctrl+G to abort, type help(). for help)
(actor@joe)1> 
```

Наша задача — изучить процессы, запущенные приложением `actor_joe`, файл `actor_joe.app` которого мы видели. Изучаем документацию `application`. Находим упоминание функции `application:get_supervisor/1`, которая по названию приложеняи возвращает ID процесса-супервизора (то есть `actor_joe_sup`). Пробуем (здесь и далее мы сразу будем выделять нужный результат в переменную с помощью _паттерн-матчинга_, но всегда можно сначала изучить полный вывод):

```
(actor@joe)1> {ok, Sup} = application:get_supervisor(actor_joe).
{ok,<0.94.0>}
```

Изучаем документацию модуля `supervisor`. Находим вызов `supervisor:which_children/1`, который возвращает список всех процессов, запущенных этим супервизором:

```
(actor@joe)2> [{_, Pid, _, _}] = supervisor:which_children(Sup).
[{actor_joe_srv,<0.95.0>,worker,[actor_joe_srv]}]
```

Теперь осталось получить _стейт_ процесса — это все данные, которые он сохраняет между сообщениями. Находим модуль `sys`, предназначенный для отладки приложений. В нём есть функция `sys:get_state/1`, которую часто упоминают на форумах, как способ получить стейт любого стандартного процесса. Попытаем удачу:

```
(actor@joe)3> #{key := Key} = sys:get_state(Pid).
#{state => 38745880,
  key =>
      <<69,78,8,86,173,124,200,193,11,220,222,85,186,231,52,152,
        66,84,244,35,188,76,125,62,253,194,210,247,...>>,
  rand_state =>
      {#{type => crypto,next => fun crypto:rand_plugin_next/1,
         bits => 64,uniform => fun crypto:rand_plugin_uniform/1,
         uniform_n => fun crypto:rand_plugin_uniform/2},
       no_seed},
  remaining_key_syncs => 0}
```

Здесь видим искомый ключ, который осталось только вывести его целиком:

```
(actor@joe)4> io:format("~p~n", [Key]).
<<69,78,8,86,173,124,200,193,11,220,222,85,186,231,52,152,66,84,244,35,188,76,
  125,62,253,194,210,247,152,171,49,171>>
ok
```

Осталось извлечь сообщения из трафика и расшифрвоать, но перед этим рассмотрим второй способ нахождения ключа.

### Находим ключ через сеть

Это более сложный способ, он требует анализа поведения приложения при запуске. Запустим Wireshark и затем снова запустим сам проект, чтобы записать весь трафик с начала. Изучим ErlDP-сообщения такого же типа, что и уже встреченные нами (`SEND_SENDER`). Удобного фильтра, который мог бы нам помочь, диссектор ErlDP не предоставляет (на самом деле нужные сообщения можно получить фильтром `erldp.small_int_ext == 22`, но это требует знания внутренностей диссектора и протокола). Поэтому будем искать по строке: Edit → Find Packet... → выбираем «String» в меню слева, и ищем `SEND_SENDER`, обращая внимание на содержимое `Message`. Сначала мы видим большое количество сообщений без каких-либо бинарных данных, а затем группу вот таких:

![](writeup/key_sync.png)

Видим здесь одну бинарную строку длиной 32 байта — то есть размером с ключ AES-256. Такие сообщения отправляются от всех нод всем нодам, то есть каждая нода получает ключ от всех других нод. Осталось понять, как эти ключи используются — если попробовать расшифровать сообщение от одной машины к другой, используя соответствующий ключ и IV, то ничего не выйдет. Здесь нам может помочь дизасемблированный код — изучив функцию `handle_cast`, в которой упоминается `crypto:exor/2`, можно прийти к выводу, что каждый присланный ключ складывается XORом с текущим ключом ноды. Таким образом, после полного обмена ключами у каждой ноды будет один и тот же финальный ключ.

Вы можете изучить [программу на Python](./solve.py), реализующую второй способ. Для работы ей необходим JSON-дамп всех пакетов из Wireshark (File → Export Packet Dissections → As JSON...). К сожалению, Wireshark генерирует файлы JSON с повторяющимися ключами в объектах — это создаёт дополнительные сложности при работе.

Флаг: **ugra_meetings_need_to_be_emails_97b2cb5d41aa88ef546b69715a210393**
